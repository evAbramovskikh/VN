# Resources\Naninovel\Characters\A\a.asset

```asset
%YAML 1.1 %TAG !u! tag:unity3d.com,2011: --- !u!114 &11400000 MonoBehaviour: m_ObjectHideFlags: 0 m_CorrespondingSourceObject: {fileID: 0} m_PrefabInstance: {fileID: 0} m_PrefabAsset: {fileID: 0} m_GameObject: {fileID: 0} m_Enabled: 1 m_EditorHideFlags: 0 m_Script: {fileID: 11500000, guid: 66cdced088f34be2bb8518f5e61f6417, type: 3} m_Name: a m_EditorClassIdentifier: metadata: Implementation: Naninovel.SpriteCharacter, Elringus.Naninovel.Runtime, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null Loader: PathPrefix: Characters ProviderTypes: - Naninovel.AddressableResourceProvider, Elringus.Naninovel.Runtime, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null - Naninovel.ProjectResourceProvider, Elringus.Naninovel.Runtime, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null guid: cd743818-3f6b-48f3-a0e2-32c5cf01c70f customData: rid: -2 Pivot: {x: 0.5, y: 0} PixelsPerUnit: 100 EnableDepthPass: 1 DepthAlphaCutoff: 0.5 CustomTextureMaterial: {fileID: 0} CustomSpriteMaterial: {fileID: 0} RenderTexture: {fileID: 0} RenderRectangle: serializedVersion: 2 x: 0 y: 0 width: 1 height: 1 BakedLookDirection: 0 HasName: 1 DisplayName: A UseCharacterColor: 0 NameColor: {r: 1, g: 1, b: 1, a: 1} MessageColor: {r: 1, g: 1, b: 1, a: 1} HighlightWhenSpeaking: 0 HighlightCharacterCount: 0 SpeakingPose: NotSpeakingPose: PlaceOnTop: 1 HighlightDuration: 0.35 HighlightEasing: 1 MessageSound: MessageSoundPlayback: 0 VoiceSource: {fileID: 0} LinkedPrinter: Poses: - name: Default actorState: appearance: visible: 0 position: {x: 0, y: -27, z: 0} rotation: {x: 0, y: 0, z: 0, w: 0} scale: {x: 0, y: 0, z: 0} tintColor: {r: 0, g: 0, b: 0, a: 0} lookDirection: 0 overriddenProperties: - position references: version: 2 RefIds: - rid: -2 type: {class: , ns: , asm: }
```

# Resources\Naninovel\Scripts\Intro.nani

```nani
@back Day @char a Idle pos:50,13 a "Пожалуйста, мне нужна ваша помощь! Справитесь?" @choice "Помочь" goto:.Agree @choice "Отказаться" goto:.Disagree @stop # Agree @addScore Value:10 @hide a @hide Dialogue @back Tavern @startPairs @back Day @checkScore good:.GoodEnd bad:.BadEnd MinGood:10 # Disagree @addScore Value:2 @hide a @hide Dialogue @back Tavern @startPairs @back Day @checkScore good:.GoodEnd bad:.BadEnd MinGood:10 # GoodEnd @char a Happy a "Спасибо за помощь! Вы настоящий герой!" @title @stop # BadEnd @char a Angry a "Жаль, что вы отказались... Это было важно." @title @stop
```

# Resources\PairsGame\Settings\GameSettings.asset

```asset
%YAML 1.1 %TAG !u! tag:unity3d.com,2011: --- !u!114 &11400000 MonoBehaviour: m_ObjectHideFlags: 0 m_CorrespondingSourceObject: {fileID: 0} m_PrefabInstance: {fileID: 0} m_PrefabAsset: {fileID: 0} m_GameObject: {fileID: 0} m_Enabled: 1 m_EditorHideFlags: 0 m_Script: {fileID: 11500000, guid: 90b4ddb4bd5c41309b85072b7e6ceae5, type: 3} m_Name: GameSettings m_EditorClassIdentifier: CardBackSprite: {fileID: 0} CardSprites: [] FlipAnimationDuration: 0.3 MatchCheckDelay: 1 CompletionDelay: 2 FlipSound: {fileID: 0} MatchSound: {fileID: 0} MismatchSound: {fileID: 0} CompletionSound: {fileID: 0}
```

# Scenes\Main.unity

```unity
%YAML 1.1 %TAG !u! tag:unity3d.com,2011: --- !u!29 &1 OcclusionCullingSettings: m_ObjectHideFlags: 0 serializedVersion: 2 m_OcclusionBakeSettings: smallestOccluder: 5 smallestHole: 0.25 backfaceThreshold: 100 m_SceneGUID: 00000000000000000000000000000000 m_OcclusionCullingData: {fileID: 0} --- !u!104 &2 RenderSettings: m_ObjectHideFlags: 0 serializedVersion: 10 m_Fog: 0 m_FogColor: {r: 0.5, g: 0.5, b: 0.5, a: 1} m_FogMode: 3 m_FogDensity: 0.01 m_LinearFogStart: 0 m_LinearFogEnd: 300 m_AmbientSkyColor: {r: 0.212, g: 0.227, b: 0.259, a: 1} m_AmbientEquatorColor: {r: 0.114, g: 0.125, b: 0.133, a: 1} m_AmbientGroundColor: {r: 0.047, g: 0.043, b: 0.035, a: 1} m_AmbientIntensity: 1 m_AmbientMode: 3 m_SubtractiveShadowColor: {r: 0.42, g: 0.478, b: 0.627, a: 1} m_SkyboxMaterial: {fileID: 0} m_HaloStrength: 0.5 m_FlareStrength: 1 m_FlareFadeSpeed: 3 m_HaloTexture: {fileID: 0} m_SpotCookie: {fileID: 10001, guid: 0000000000000000e000000000000000, type: 0} m_DefaultReflectionMode: 0 m_DefaultReflectionResolution: 128 m_ReflectionBounces: 1 m_ReflectionIntensity: 1 m_CustomReflection: {fileID: 0} m_Sun: {fileID: 0} m_UseRadianceAmbientProbe: 0 --- !u!157 &3 LightmapSettings: m_ObjectHideFlags: 0 serializedVersion: 13 m_BakeOnSceneLoad: 0 m_GISettings: serializedVersion: 2 m_BounceScale: 1 m_IndirectOutputScale: 1 m_AlbedoBoost: 1 m_EnvironmentLightingMode: 0 m_EnableBakedLightmaps: 0 m_EnableRealtimeLightmaps: 0 m_LightmapEditorSettings: serializedVersion: 12 m_Resolution: 2 m_BakeResolution: 40 m_AtlasSize: 1024 m_AO: 0 m_AOMaxDistance: 1 m_CompAOExponent: 1 m_CompAOExponentDirect: 0 m_ExtractAmbientOcclusion: 0 m_Padding: 2 m_LightmapParameters: {fileID: 0} m_LightmapsBakeMode: 1 m_TextureCompression: 1 m_ReflectionCompression: 2 m_MixedBakeMode: 2 m_BakeBackend: 1 m_PVRSampling: 1 m_PVRDirectSampleCount: 32 m_PVRSampleCount: 512 m_PVRBounces: 2 m_PVREnvironmentSampleCount: 256 m_PVREnvironmentReferencePointCount: 2048 m_PVRFilteringMode: 1 m_PVRDenoiserTypeDirect: 1 m_PVRDenoiserTypeIndirect: 1 m_PVRDenoiserTypeAO: 1 m_PVRFilterTypeDirect: 0 m_PVRFilterTypeIndirect: 0 m_PVRFilterTypeAO: 0 m_PVREnvironmentMIS: 1 m_PVRCulling: 1 m_PVRFilteringGaussRadiusDirect: 1 m_PVRFilteringGaussRadiusIndirect: 5 m_PVRFilteringGaussRadiusAO: 2 m_PVRFilteringAtrousPositionSigmaDirect: 0.5 m_PVRFilteringAtrousPositionSigmaIndirect: 2 m_PVRFilteringAtrousPositionSigmaAO: 1 m_ExportTrainingData: 0 m_TrainingDataDestination: TrainingData m_LightProbeSampleCountMultiplier: 4 m_LightingDataAsset: {fileID: 0} m_LightingSettings: {fileID: 0} --- !u!196 &4 NavMeshSettings: serializedVersion: 2 m_ObjectHideFlags: 0 m_BuildSettings: serializedVersion: 3 agentTypeID: 0 agentRadius: 0.5 agentHeight: 2 agentSlope: 45 agentClimb: 0.4 ledgeDropHeight: 0 maxJumpAcrossDistance: 0 minRegionArea: 2 manualCellSize: 0 cellSize: 0.16666667 manualTileSize: 0 tileSize: 256 buildHeightMesh: 0 maxJobWorkers: 0 preserveTilesOutsideBounds: 0 debug: m_Flags: 0 m_NavMeshData: {fileID: 0} --- !u!1660057539 &9223372036854775807 SceneRoots: m_ObjectHideFlags: 0 m_Roots: []
```

# Scenes\PairsGame.unity

```unity
%YAML 1.1 %TAG !u! tag:unity3d.com,2011: --- !u!29 &1 OcclusionCullingSettings: m_ObjectHideFlags: 0 serializedVersion: 2 m_OcclusionBakeSettings: smallestOccluder: 5 smallestHole: 0.25 backfaceThreshold: 100 m_SceneGUID: 00000000000000000000000000000000 m_OcclusionCullingData: {fileID: 0} --- !u!104 &2 RenderSettings: m_ObjectHideFlags: 0 serializedVersion: 10 m_Fog: 0 m_FogColor: {r: 0.5, g: 0.5, b: 0.5, a: 1} m_FogMode: 3 m_FogDensity: 0.01 m_LinearFogStart: 0 m_LinearFogEnd: 300 m_AmbientSkyColor: {r: 0.212, g: 0.227, b: 0.259, a: 1} m_AmbientEquatorColor: {r: 0.114, g: 0.125, b: 0.133, a: 1} m_AmbientGroundColor: {r: 0.047, g: 0.043, b: 0.035, a: 1} m_AmbientIntensity: 1 m_AmbientMode: 3 m_SubtractiveShadowColor: {r: 0.42, g: 0.478, b: 0.627, a: 1} m_SkyboxMaterial: {fileID: 0} m_HaloStrength: 0.5 m_FlareStrength: 1 m_FlareFadeSpeed: 3 m_HaloTexture: {fileID: 0} m_SpotCookie: {fileID: 10001, guid: 0000000000000000e000000000000000, type: 0} m_DefaultReflectionMode: 0 m_DefaultReflectionResolution: 128 m_ReflectionBounces: 1 m_ReflectionIntensity: 1 m_CustomReflection: {fileID: 0} m_Sun: {fileID: 0} m_UseRadianceAmbientProbe: 0 --- !u!157 &3 LightmapSettings: m_ObjectHideFlags: 0 serializedVersion: 13 m_BakeOnSceneLoad: 0 m_GISettings: serializedVersion: 2 m_BounceScale: 1 m_IndirectOutputScale: 1 m_AlbedoBoost: 1 m_EnvironmentLightingMode: 0 m_EnableBakedLightmaps: 0 m_EnableRealtimeLightmaps: 0 m_LightmapEditorSettings: serializedVersion: 12 m_Resolution: 2 m_BakeResolution: 40 m_AtlasSize: 1024 m_AO: 0 m_AOMaxDistance: 1 m_CompAOExponent: 1 m_CompAOExponentDirect: 0 m_ExtractAmbientOcclusion: 0 m_Padding: 2 m_LightmapParameters: {fileID: 0} m_LightmapsBakeMode: 1 m_TextureCompression: 1 m_ReflectionCompression: 2 m_MixedBakeMode: 2 m_BakeBackend: 1 m_PVRSampling: 1 m_PVRDirectSampleCount: 32 m_PVRSampleCount: 512 m_PVRBounces: 2 m_PVREnvironmentSampleCount: 256 m_PVREnvironmentReferencePointCount: 2048 m_PVRFilteringMode: 1 m_PVRDenoiserTypeDirect: 1 m_PVRDenoiserTypeIndirect: 1 m_PVRDenoiserTypeAO: 1 m_PVRFilterTypeDirect: 0 m_PVRFilterTypeIndirect: 0 m_PVRFilterTypeAO: 0 m_PVREnvironmentMIS: 1 m_PVRCulling: 1 m_PVRFilteringGaussRadiusDirect: 1 m_PVRFilteringGaussRadiusIndirect: 5 m_PVRFilteringGaussRadiusAO: 2 m_PVRFilteringAtrousPositionSigmaDirect: 0.5 m_PVRFilteringAtrousPositionSigmaIndirect: 2 m_PVRFilteringAtrousPositionSigmaAO: 1 m_ExportTrainingData: 0 m_TrainingDataDestination: TrainingData m_LightProbeSampleCountMultiplier: 4 m_LightingDataAsset: {fileID: 0} m_LightingSettings: {fileID: 0} --- !u!196 &4 NavMeshSettings: serializedVersion: 2 m_ObjectHideFlags: 0 m_BuildSettings: serializedVersion: 3 agentTypeID: 0 agentRadius: 0.5 agentHeight: 2 agentSlope: 45 agentClimb: 0.4 ledgeDropHeight: 0 maxJumpAcrossDistance: 0 minRegionArea: 2 manualCellSize: 0 cellSize: 0.16666667 manualTileSize: 0 tileSize: 256 buildHeightMesh: 0 maxJobWorkers: 0 preserveTilesOutsideBounds: 0 debug: m_Flags: 0 m_NavMeshData: {fileID: 0} --- !u!1660057539 &9223372036854775807 SceneRoots: m_ObjectHideFlags: 0 m_Roots: []
```

# Scripts\DI\PairsGameLifetimeScope.cs

```cs
using PairsGame.Application.Presenters; using PairsGame.Domain.Services; using PairsGame.Infrastructure; using PairsGame.UI.Views; using UnityEngine; using VContainer; using VContainer.Unity; namespace DI { /// <summary> /// DI конфигурация для мини-игры /// </summary> public sealed class PairsGameLifetimeScope : LifetimeScope { [SerializeField] private PairsGameView _gameViewPrefab; [SerializeField] private GameSettings _gameSettings; protected override void Configure(IContainerBuilder builder) { // Регистрируем настройки builder.RegisterInstance(_gameSettings).As<GameSettings>(); // Domain Layer builder.Register<ICardRepository, CardRepository>(Lifetime.Scoped); builder.Register<IGameService, GameService>(Lifetime.Scoped); // Infrastructure builder.Register<CardFactory>(Lifetime.Scoped); // Presentation Layer builder.RegisterComponentInNewPrefab(_gameViewPrefab, Lifetime.Scoped) .As<IPairsGameView>(); builder.Register<IPairsGamePresenter, PairsGamePresenter>(Lifetime.Scoped); // Entry Point builder.RegisterEntryPoint<PairsGamePresenter>(); } } }
```

# Scripts\Novel\Commands\NovelCommands.cs

```cs
using Naninovel; using Naninovel.Commands; using UniTask = Naninovel.UniTask; [CommandAlias("addScore")] public class AddScore : Command { [RequiredParameter] public IntegerParameter Value; public override UniTask Execute(AsyncToken _) { Engine.GetService<ScoreService>().Add(Value); return UniTask.CompletedTask; } } [CommandAlias("checkScore")] public class CheckScore : Command { [RequiredParameter] public NamedStringParameter bad; [RequiredParameter] public NamedStringParameter good; [ParameterAlias("MinGood")] public IntegerParameter Threshold = 10; public override UniTask Execute(AsyncToken token = default) { var score = Engine.GetService<ScoreService>().Get(); var target = score >= Threshold ? good : bad; return new Goto { Path = target }.Execute(token); } }
```

# Scripts\Novel\Commands\StartPairs.cs

```cs
using System; using Naninovel; /// <summary> /// Временно имитирует мини-игру: просто ждёт 5 секунд и возвращается к сценарию. /// </summary> [CommandAlias("startPairs")] public sealed class StartPairs : Command { public override async Naninovel.UniTask Execute (AsyncToken token = default) { // ждём 5 секунд, поддерживая отмену (Esc, переход к save/load и т.д.) await Naninovel.UniTask.Delay(TimeSpan.FromSeconds(5), cancellationToken: token.CancellationToken); } }
```

# Scripts\Novel\Services\ScoreService.cs

```cs
using System; using Naninovel; using UniRx; using UniTask = Naninovel.UniTask; [InitializeAtRuntime] public sealed class ScoreService : IEngineService, IStatefulService<GameStateMap> { public readonly ReactiveProperty<int> Current = new(0); public UniTask InitializeService() { return UniTask.CompletedTask; } public void ResetService() { Current.Value = 0; } public void DestroyService() { } public void SaveServiceState(GameStateMap map) { map.SetState(new ScoreState { Value = Current.Value }); } public UniTask LoadServiceState(GameStateMap map) { var snap = map.GetState<ScoreState>(); if (snap != null) Current.Value = snap.Value; return UniTask.CompletedTask; } public void Add(int v) { Current.Value += v; } public int Get() { return Current.Value; } } [Serializable] internal class ScoreState { public int Value; }
```

# Scripts\PairsGame\Application\Presenters\IPairsGamePresenter.cs

```cs
using System; using Cysharp.Threading.Tasks; namespace PairsGame.Application.Presenters { /// <summary> /// Интерфейс презентера игры /// </summary> public interface IPairsGamePresenter : IDisposable { UniTask Initialize(); UniTask StartGame(); UniTask OnCardClicked(int cardIndex); } }
```

# Scripts\PairsGame\Application\Presenters\PairsGamePresenter.cs

```cs
using System; using System.Linq; using Cysharp.Threading.Tasks; using UniRx; using VContainer.Unity; using PairsGame.Domain.Models; using PairsGame.Domain.Services; using PairsGame.Infrastructure; using PairsGame.UI.Views; namespace PairsGame.Application.Presenters { /// <summary>Данные для события «пара найдена».</summary> public readonly struct MatchFoundData { public MatchFoundData(Card first, Card second) { First = first; Second = second; } public Card First { get; } public Card Second { get; } } /// <summary>Данные для события «игра завершена».</summary> public readonly struct GameCompletedData { public GameCompletedData(int moves) => Moves = moves; public int Moves { get; } } /// <summary> /// Реактивный презентер мини-игры без использования dynamic. /// </summary> public sealed class PairsGamePresenter : IPairsGamePresenter, IInitializable, IDisposable { private readonly IGameService _gameService; private readonly IPairsGameView _gameView; private readonly GameSettings _settings; private readonly CompositeDisposable _disposables = new(); public PairsGamePresenter( IGameService gameService, IPairsGameView gameView, GameSettings settings) { _gameService = gameService; _gameView = gameView; _settings = settings; } /// <summary> /// IInitializable /// </summary> void IInitializable.Initialize() => Initialize().Forget(); public async UniTask Initialize() { SubscribeCardClicks(); SubscribeGameState(); SubscribeGameEvents(); await StartGame(); } /// <summary> /// Public API /// </summary> public async UniTask StartGame() { _gameView.ShowLoading(); await _gameService.StartNewGame(); _gameView.HideLoading(); } public async UniTask OnCardClicked(int cardIndex) { var state = _gameService.CurrentGameState.Value; if (state == null || cardIndex < 0 || cardIndex >= state.Cards.Count) return; await _gameService.TryFlipCard(state.Cards[cardIndex]); } /// <summary> /// Subscriptions /// </summary> private void SubscribeCardClicks() { _gameView.OnCardClicked .ThrottleFirst(TimeSpan.FromMilliseconds(300)) .Subscribe(i => OnCardClicked(i).Forget()) .AddTo(_disposables); } private void SubscribeGameState() { _gameService.CurrentGameState .Where(s => s != null) .Subscribe(BindGameState) .AddTo(_disposables); } private void SubscribeGameEvents() { _gameService.GameEvents .Subscribe(HandleGameEvent) .AddTo(_disposables); _gameService.GameEvents .Where(e => e.Type == GameEventType.GameCompleted) .Subscribe(_ => PairsGameBridge.NotifyGameCompleted()) .AddTo(_disposables); } private void HandleGameEvent(GameEvent e) { switch (e.Type) { case GameEventType.GameStarted: _gameView.ShowStartAnimation(); break; case GameEventType.CardFlipped: _gameView.PlaySound(SoundType.Flip); break; case GameEventType.MatchFound: if (e.Data is MatchFoundData m) { _gameView.ShowMatchAnimation(m.First.Position, m.Second.Position); } _gameView.PlaySound(SoundType.Match); break; case GameEventType.MismatchFound: _gameView.PlaySound(SoundType.Mismatch); break; case GameEventType.GameCompleted: HandleGameCompleted(e.Data).Forget(); break; } } /// <summary> /// Bindings /// </summary> private void BindGameState(GameState state) { state.MovesCount .Subscribe(_gameView.SetMovesCount) .AddTo(_disposables); state.MatchesFound .CombineLatest(Observable.Return(state.TotalPairs), (m, t) => (m, t)) .Subscribe(x => _gameView.SetMatchesCount(x.m, x.t)) .AddTo(_disposables); state.IsProcessing .Subscribe(p => _gameView.SetInteractionEnabled(!p)) .AddTo(_disposables); BindCards(state); } private void BindCards(GameState state) { for (int i = 0; i < state.Cards.Count; i++) { var card = state.Cards[i]; var cardView = _gameView.GetCardView(i); if (cardView == null) continue; cardView.SetCardImage(_settings.GetCardSprite(card.PairId)); Observable.CombineLatest(card.IsFlipped, card.IsMatched, card.IsInteractable, (f, m, iable) => (f, m, iable)) .Subscribe(s => { cardView.SetFlipped(s.f); cardView.SetMatched(s.m); cardView.SetInteractable(s.iable); }) .AddTo(_disposables); } } /// <summary> /// Helpers /// </summary> private async UniTaskVoid HandleGameCompleted(object data) { var moves = data is GameCompletedData g ? g.Moves : 0; await UniTask.Delay(TimeSpan.FromSeconds(0.5f)); _gameView.ShowGameCompleted(moves); _gameView.PlaySound(SoundType.Complete); await UniTask.Delay(TimeSpan.FromSeconds(2)); } /// <summary> /// IDisposable /// </summary> public void Dispose() { _disposables.Dispose(); _gameService.Dispose(); } } /// <summary> /// мост в Naninovel /// </summary> public static class PairsGameBridge { public static readonly Subject<Unit> GameCompleted = new(); public static void NotifyGameCompleted() => GameCompleted.OnNext(Unit.Default); } public enum SoundType { Flip, Match, Mismatch, Complete } }
```

# Scripts\PairsGame\Domain\Commands\GameCommands.cs

```cs
using System; using PairsGame.Domain.Models; using Cysharp.Threading.Tasks; namespace PairsGame.Domain.Commands { /// <summary> /// Интерфейс команды (паттерн Command) /// </summary> public interface IGameCommand { UniTask Execute(); UniTask Undo(); } /// <summary> /// Команда переворота карты /// </summary> public sealed class FlipCardCommand : IGameCommand { private readonly Card _card; private readonly GameState _gameState; private bool _wasExecuted; public FlipCardCommand(Card card, GameState gameState) { _card = card; _gameState = gameState; } public UniTask Execute() { if (!_wasExecuted) { _card.Flip(); _gameState.FlippedCards.Add(_card); _gameState.MovesCount.Value++; _wasExecuted = true; } return UniTask.CompletedTask; } public UniTask Undo() { if (_wasExecuted) { _card.Hide(); _gameState.FlippedCards.Remove(_card); _gameState.MovesCount.Value--; _wasExecuted = false; } return UniTask.CompletedTask; } } /// <summary> /// Команда для пары найденных карт /// </summary> public sealed class MatchCardsCommand : IGameCommand { private readonly Card _firstCard; private readonly Card _secondCard; private readonly GameState _gameState; private bool _wasExecuted; public MatchCardsCommand(Card firstCard, Card secondCard, GameState gameState) { _firstCard = firstCard; _secondCard = secondCard; _gameState = gameState; } public UniTask Execute() { if (!_wasExecuted) { _firstCard.MarkAsMatched(); _secondCard.MarkAsMatched(); _gameState.MatchesFound.Value++; _wasExecuted = true; } return UniTask.CompletedTask; } public UniTask Undo() { if (_wasExecuted) { _firstCard.IsMatched.Value = false; _secondCard.IsMatched.Value = false; _firstCard.Hide(); _secondCard.Hide(); _gameState.MatchesFound.Value--; _wasExecuted = false; } return UniTask.CompletedTask; } } /// <summary> /// Команда скрытия карт при несовпадении /// </summary> public sealed class HideCardsCommand : IGameCommand { private readonly Card _firstCard; private readonly Card _secondCard; public HideCardsCommand(Card firstCard, Card secondCard) { _firstCard = firstCard; _secondCard = secondCard; } public UniTask Execute() { _firstCard.Hide(); _secondCard.Hide(); return UniTask.CompletedTask; } public UniTask Undo() { _firstCard.Flip(); _secondCard.Flip(); return UniTask.CompletedTask; } } }
```

# Scripts\PairsGame\Domain\Models\Card.cs

```cs
using System; using UniRx; namespace PairsGame.Domain.Models { /// <summary> /// Модель карты в игре /// </summary> public sealed class Card { public string Id { get; } public int PairId { get; } public int Position { get; } // Реактивные свойства для отслеживания состояния public IReactiveProperty<bool> IsFlipped { get; } public IReactiveProperty<bool> IsMatched { get; } public IReadOnlyReactiveProperty<bool> IsInteractable { get; } public Card(string id, int pairId, int position) { Id = id; PairId = pairId; Position = position; IsFlipped = new ReactiveProperty<bool>(false); IsMatched = new ReactiveProperty<bool>(false); IsInteractable = IsFlipped .CombineLatest(IsMatched, (flipped, matched) => !flipped && !matched) .ToReadOnlyReactiveProperty(); } public void Flip() => IsFlipped.Value = true; public void Hide() => IsFlipped.Value = false; public void MarkAsMatched() => IsMatched.Value = true; } }
```

# Scripts\PairsGame\Domain\Models\GameState.cs

```cs
using System; using System.Collections.Generic; using UniRx; namespace PairsGame.Domain.Models { /// <summary> /// Состояние игры /// </summary> public sealed class GameState { // Реактивные свойства для отслеживания состояния игры public IReactiveProperty<int> MovesCount { get; } public IReactiveProperty<int> MatchesFound { get; } public IReactiveProperty<bool> IsProcessing { get; } public IReactiveProperty<bool> IsGameCompleted { get; } // Карты на поле public IReadOnlyList<Card> Cards { get; } // Текущие открытые карты public ReactiveCollection<Card> FlippedCards { get; } // Настройки игры public int TotalPairs { get; } public int GridSize { get; } public GameState(IReadOnlyList<Card> cards, int gridSize = 4) { Cards = cards; GridSize = gridSize; TotalPairs = cards.Count / 2; MovesCount = new ReactiveProperty<int>(0); MatchesFound = new ReactiveProperty<int>(0); IsProcessing = new ReactiveProperty<bool>(false); IsGameCompleted = new ReactiveProperty<bool>(false); FlippedCards = new ReactiveCollection<Card>(); MatchesFound .Where(matches => matches == TotalPairs) .Subscribe(_ => IsGameCompleted.Value = true); } public void Reset() { MovesCount.Value = 0; MatchesFound.Value = 0; IsProcessing.Value = false; IsGameCompleted.Value = false; FlippedCards.Clear(); foreach (var card in Cards) { card.IsFlipped.Value = false; card.IsMatched.Value = false; } } } }
```

# Scripts\PairsGame\Domain\Repositories\ICardRepository.cs

```cs
using PairsGame.Domain.Models; using Cysharp.Threading.Tasks; namespace PairsGame.Domain.Services { public interface ICardRepository { UniTask<Card[]> GenerateCards(int gridSize); } }
```

# Scripts\PairsGame\Domain\Services\GameService.cs

```cs
using System; using System.Collections.Generic; using PairsGame.Domain.Models; using PairsGame.Domain.Commands; using UniRx; using Cysharp.Threading.Tasks; using PairsGame.Application.Presenters; namespace PairsGame.Domain.Services { /// <summary> /// События игры для интеграции с Naninovel /// </summary> public enum GameEventType { GameStarted, CardFlipped, MatchFound, MismatchFound, GameCompleted, MoveUndone } public class GameEvent { public GameEventType Type { get; } public object Data { get; } public GameEvent(GameEventType type, object data = null) { Type = type; Data = data; } } /// <summary> /// Реализация игрового сервиса с паттерном Command /// </summary> public sealed class GameService : IGameService, IDisposable { private readonly ICardRepository _cardRepository; private readonly ReactiveProperty<GameState> _gameState; private readonly Subject<GameEvent> _gameEvents; private readonly Stack<IGameCommand> _commandHistory; private readonly CompositeDisposable _disposables; public IReadOnlyReactiveProperty<GameState> CurrentGameState => _gameState; public IObservable<GameEvent> GameEvents => _gameEvents; public GameService(ICardRepository cardRepository) { _cardRepository = cardRepository; _gameState = new ReactiveProperty<GameState>(); _gameEvents = new Subject<GameEvent>(); _commandHistory = new Stack<IGameCommand>(); _disposables = new CompositeDisposable(); } public async UniTask StartNewGame(int gridSize = 4) { // Очищаем историю команд _commandHistory.Clear(); // Получаем карты из репозитория var cards = await _cardRepository.GenerateCards(gridSize); // Создаем новое состояние игры var newState = new GameState(cards, gridSize); _gameState.Value = newState; // Подписываемся на изменения состояния SetupGameStateSubscriptions(newState); // Отправляем событие начала игры _gameEvents.OnNext(new GameEvent(GameEventType.GameStarted, gridSize)); } public async UniTask<bool> TryFlipCard(Card card) { var state = _gameState.Value; if (state == null || state.IsProcessing.Value || !card.IsInteractable.Value) return false; // Создаем и выполняем команду var command = new FlipCardCommand(card, state); await ExecuteCommand(command); // Отправляем событие _gameEvents.OnNext(new GameEvent(GameEventType.CardFlipped, card)); // Если открыты 2 карты, проверяем совпадение if (state.FlippedCards.Count == 2) { state.IsProcessing.Value = true; await CheckForMatch(); } return true; } public async UniTask CheckForMatch() { var state = _gameState.Value; if (state.FlippedCards.Count != 2) return; var firstCard = state.FlippedCards[0]; var secondCard = state.FlippedCards[1]; // Даем время увидеть обе карты await UniTask.Delay(TimeSpan.FromSeconds(1)); if (firstCard.PairId == secondCard.PairId) { // Найдена пара! var command = new MatchCardsCommand(firstCard, secondCard, state); await ExecuteCommand(command); _gameEvents.OnNext(new GameEvent(GameEventType.MatchFound, new MatchFoundData(firstCard, secondCard))); } else { // Не совпало - переворачиваем обратно var command = new HideCardsCommand(firstCard, secondCard); await ExecuteCommand(command); _gameEvents.OnNext(new GameEvent(GameEventType.MismatchFound)); } state.FlippedCards.Clear(); state.IsProcessing.Value = false; } public async UniTask UndoLastMove() { if (_commandHistory.Count == 0) return; var command = _commandHistory.Pop(); await command.Undo(); _gameEvents.OnNext(new GameEvent(GameEventType.MoveUndone)); } private async UniTask ExecuteCommand(IGameCommand command) { await command.Execute(); _commandHistory.Push(command); } private void SetupGameStateSubscriptions(GameState state) { // Очищаем предыдущие подписки _disposables.Clear(); // Подписываемся на завершение игры state.IsGameCompleted .Where(completed => completed) .Subscribe(_ => { _gameEvents.OnNext(new GameEvent(GameEventType.GameCompleted, new GameCompletedData(state.MovesCount.Value))); }) .AddTo(_disposables); } public void Dispose() { _disposables?.Dispose(); _gameState?.Dispose(); _gameEvents?.Dispose(); } } }
```

# Scripts\PairsGame\Domain\Services\IGameService.cs

```cs
using System; using PairsGame.Domain.Models; using UniRx; using Cysharp.Threading.Tasks; namespace PairsGame.Domain.Services { /// <summary> /// Интерфейс игрового сервиса /// </summary> public interface IGameService { IReadOnlyReactiveProperty<GameState> CurrentGameState { get; } IObservable<GameEvent> GameEvents { get; } UniTask StartNewGame(int gridSize = 4); UniTask<bool> TryFlipCard(Card card); UniTask CheckForMatch(); UniTask UndoLastMove(); void Dispose(); } }
```

# Scripts\PairsGame\Infrastructure\CardFactory.cs

```cs
using PairsGame.Domain.Models; namespace PairsGame.Infrastructure { /// <summary> /// Фабрика для создания карт /// </summary> public sealed class CardFactory { public Card CreateCard(int position, int pairId) { var id = $"card_{position}"; return new Card(id, pairId, position); } } }
```

# Scripts\PairsGame\Infrastructure\CardRepository.cs

```cs
using System.Collections.Generic; using PairsGame.Domain.Models; using PairsGame.Domain.Services; using Cysharp.Threading.Tasks; using UnityEngine; namespace PairsGame.Infrastructure { /// <summary> /// Репозиторий карт - отвечает за генерацию и перемешивание карт /// </summary> public sealed class CardRepository : ICardRepository { private readonly CardFactory _cardFactory; private readonly GameSettings _settings; public CardRepository(CardFactory cardFactory, GameSettings settings) { _cardFactory = cardFactory; _settings = settings; } public async UniTask<Card[]> GenerateCards(int gridSize) { var totalCards = gridSize * gridSize; var pairsCount = totalCards / 2; var cards = new Card[totalCards]; var pairIds = GenerateShuffledPairIds(pairsCount); // Создаем карты for (int i = 0; i < totalCards; i++) { cards[i] = _cardFactory.CreateCard(i, pairIds[i]); } // Имитация асинхронной загрузки (например, загрузка спрайтов) await UniTask.Delay(100); return cards; } private List<int> GenerateShuffledPairIds(int pairsCount) { var pairIds = new List<int>(pairsCount * 2); // Создаем пары ID for (int i = 0; i < pairsCount; i++) { pairIds.Add(i); pairIds.Add(i); } // Перемешиваем используя Fisher-Yates shuffle for (int i = pairIds.Count - 1; i > 0; i--) { var randomIndex = Random.Range(0, i + 1); (pairIds[i], pairIds[randomIndex]) = (pairIds[randomIndex], pairIds[i]); } return pairIds; } } }
```

# Scripts\PairsGame\Infrastructure\GameSettings.cs

```cs
using UnityEngine; namespace PairsGame.Infrastructure { /// <summary> /// Настройки игры /// </summary> [CreateAssetMenu(fileName = "GameSettings", menuName = "PairsGame/Settings")] public class GameSettings : ScriptableObject { [Header("Визуальные настройки")] public Sprite CardBackSprite; public Sprite[] CardSprites; [Header("Игровые настройки")] public float FlipAnimationDuration = 0.3f; public float MatchCheckDelay = 1f; public float CompletionDelay = 2f; [Header("Звуки")] public AudioClip FlipSound; public AudioClip MatchSound; public AudioClip MismatchSound; public AudioClip CompletionSound; public Sprite GetCardSprite(int pairId) { if (CardSprites == null || CardSprites.Length == 0) return null; return CardSprites[pairId % CardSprites.Length]; } } }
```

# Scripts\PairsGame\UI\UIDocuments\PairsGame.uss

```uss
/* Основной контейнер */ .game-container { flex-grow: 1; background-color: #1a1a2e; padding: 20px; align-items: center; justify-content: center; } /* Заголовок с информацией */ .header { flex-direction: column; align-items: center; width: 600px; margin-bottom: 20px; } .info-label { font-size: 24px; color: #eeeeee; -unity-font-style: bold; -unity-text-outline-width: 2px; -unity-text-outline-color: rgba(0, 0, 0, 0.5); margin-bottom: 10px; } /* Прогресс бар */ .progress-bar { width: 100%; height: 8px; background-color: rgba(255, 255, 255, 0.1); border-radius: 4px; } .progress-fill { height: 100%; background-color: #4CAF50; transition-duration: 0.3s; transition-property: width; } /* Игровое поле */ .board { width: 600px; height: 600px; flex-direction: row; flex-wrap: wrap; justify-content: space-between; align-content: center; } /* Карта */ .card { width: 140px; height: 140px; margin: 5px; border-radius: 10px; border-width: 2px; border-color: #0f3460; transition-duration: 0.2s; transition-property: scale; } .card:hover { scale: 1.05; border-color: #e94560; } .card.disabled { opacity: 0.8; } .card.matched { opacity: 0.3; border-color: #4CAF50; } /* Лица карты */ .card-face { position: absolute; width: 100%; height: 100%; -unity-background-scale-mode: scale-to-fit; } .card-back { background-color: #0f3460; } .card-front { background-color: #eeeeee; display: none; } .card-front.visible { display: flex; } .card-back.hidden { display: none; } /* Оверлеи */ .overlay { position: absolute; left: 0; top: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.8); align-items: center; justify-content: center; } /* Загрузка */ .loading-overlay { background-color: rgba(0, 0, 0, 0.9); } .loading-text { font-size: 36px; color: #ffffff; -unity-font-style: bold; } /* Завершение игры */ .completed-overlay { background-color: rgba(0, 0, 0, 0.85); } .completed-content { align-items: center; padding: 40px; background-color: #16213e; border-radius: 20px; border-width: 3px; border-color: #4CAF50; } .completed-title { font-size: 48px; color: #4CAF50; -unity-font-style: bold; margin-bottom: 10px; } .completed-subtitle { font-size: 24px; color: #eeeeee; margin-bottom: 10px; } .completed-moves { font-size: 20px; color: #cccccc; } /* Эффекты анимации */ .pulse { transition-duration: 0.3s; transition-property: scale; scale: 1.1; } .fade-in { opacity: 1; transition-duration: 0.3s; transition-property: opacity; } .fade-out { opacity: 0; transition-duration: 0.3s; transition-property: opacity; } /* Анимация появления карт */ .card-appear { opacity: 0; translate: 0 20px 0; transition-duration: 0.5s; transition-property: opacity; } .card-appear.show { opacity: 1; translate: 0 0 0; } /* Простая анимация переворота */ .card-flipping { transition-duration: 0.3s; transition-property: scale; scale: 0.1 1 1; } /* Состояния видимости для анимаций */ .show-completed { opacity: 1; scale: 1 1 1; transition-duration: 0.5s; transition-property: opacity; }
```

# Scripts\PairsGame\UI\UIDocuments\PairsGame.uxml

```uxml
<ui:UXML xmlns:ui="UnityEngine.UIElements" xmlns:uie="UnityEditor.UIElements"> <ui:VisualElement name="pairs-game-root" class="game-container"> <!-- Игровая информация --> <ui:VisualElement name="game-header" class="header"> <ui:Label name="moves-count" text="Ходов: 0" class="info-label" /> <ui:Label name="matches-count" text="Найдено пар: 0/8" class="info-label" /> <ui:VisualElement name="progress-bar" class="progress-bar"> <ui:VisualElement name="progress-fill" class="progress-fill" /> </ui:VisualElement> </ui:VisualElement> <!-- Игровое поле --> <ui:VisualElement name="game-board" class="board"> <!-- Карты будут добавлены динамически --> </ui:VisualElement> <!-- Оверлей загрузки --> <ui:VisualElement name="loading-overlay" class="overlay loading-overlay" style="display: none;"> <ui:Label text="Загрузка..." class="loading-text" /> </ui:VisualElement> <!-- Оверлей завершения игры --> <ui:VisualElement name="completed-overlay" class="overlay completed-overlay" style="display: none;"> <ui:VisualElement class="completed-content"> <ui:Label text="Поздравляем!" class="completed-title" /> <ui:Label text="Вы нашли все пары!" class="completed-subtitle" /> <ui:Label name="completed-moves" text="" class="completed-moves" /> </ui:VisualElement> </ui:VisualElement> </ui:VisualElement> </ui:UXML>
```

# Scripts\PairsGame\UI\Views\CardView.cs

```cs
using System; using UnityEngine; using UnityEngine.UIElements; using Cysharp.Threading.Tasks; namespace PairsGame.UI.Views { /// <summary> /// Интерфейс представления карты /// </summary> public interface ICardView { void SetFlipped(bool flipped); void SetMatched(bool matched); void SetInteractable(bool interactable); void SetCardImage(Sprite sprite); VisualElement CreateVisualElement(); } /// <summary> /// View карты с простыми анимациями /// </summary> public class CardView : MonoBehaviour, ICardView { [SerializeField] private float _flipDuration = 0.3f; private VisualElement _cardElement; private VisualElement _cardImage; private Sprite _backSprite; private Sprite _frontSprite; private bool _isFlipped; private bool _isMatched; // Инжектируем спрайт рубашки через настройки public void Initialize(Sprite backSprite) { _backSprite = backSprite; } public VisualElement CreateVisualElement() { _cardElement = new VisualElement(); _cardElement.AddToClassList("card"); _cardImage = new VisualElement(); _cardImage.AddToClassList("card-face"); _cardImage.style.position = Position.Absolute; // Изначально показываем рубашку if (_backSprite != null) { _cardImage.style.backgroundImage = new StyleBackground(_backSprite); } _cardElement.Add(_cardImage); return _cardElement; } public void SetFlipped(bool flipped) { if (_isFlipped == flipped) return; _isFlipped = flipped; AnimateFlip(flipped).Forget(); } private async UniTaskVoid AnimateFlip(bool flipped) { // Анимация сжатия _cardElement.AddToClassList("card-flipping"); // Ждем половину анимации await UniTask.Delay(TimeSpan.FromSeconds(_flipDuration / 2)); // Меняем спрайт if (flipped && _frontSprite != null) { _cardImage.style.backgroundImage = new StyleBackground(_frontSprite); } else if (!flipped && _backSprite != null) { _cardImage.style.backgroundImage = new StyleBackground(_backSprite); } // Ждем окончания анимации await UniTask.Delay(TimeSpan.FromSeconds(_flipDuration / 2)); _cardElement.RemoveFromClassList("card-flipping"); } public void SetMatched(bool matched) { if (_isMatched == matched) return; _isMatched = matched; if (matched) { _cardElement.AddToClassList("matched"); // Анимация успешного совпадения ShowMatchEffect(); } else { _cardElement.RemoveFromClassList("matched"); } } private void ShowMatchEffect() { // Эффект пульсации _cardElement.AddToClassList("pulse"); _cardElement.schedule.Execute(() => { _cardElement.RemoveFromClassList("pulse"); }).StartingIn(300); } public void SetInteractable(bool interactable) { _cardElement.pickingMode = interactable ? PickingMode.Position : PickingMode.Ignore; if (interactable) { _cardElement.RemoveFromClassList("disabled"); } else { _cardElement.AddToClassList("disabled"); } } public void SetCardImage(Sprite sprite) { _frontSprite = sprite; } } }
```

# Scripts\PairsGame\UI\Views\PairsGameView.cs

```cs
using System; using System.Collections.Generic; using UnityEngine; using UnityEngine.UIElements; using UniRx; using Cysharp.Threading.Tasks; using PairsGame.Application.Presenters; using PairsGame.Infrastructure; namespace PairsGame.UI.Views { /// <summary> /// Интерфейс представления игры /// </summary> public interface IPairsGameView { IObservable<int> OnCardClicked { get; } void ShowLoading(); void HideLoading(); void SetMovesCount(int moves); void SetMatchesCount(int matches, int total); void SetInteractionEnabled(bool enabled); void ShowGameCompleted(int moves); void ShowStartAnimation(); void ShowMatchAnimation(int firstCardIndex, int secondCardIndex); void PlaySound(SoundType soundType); ICardView GetCardView(int index); } /// <summary> /// View игры с UI Toolkit /// </summary> public sealed class PairsGameView : MonoBehaviour, IPairsGameView { [SerializeField] private UIDocument _uiDocument; [SerializeField] private CardView _cardPrefab; [SerializeField] private GameSettings _gameSettings; [Header("Audio")] [SerializeField] private AudioSource _audioSource; private VisualElement _root; private VisualElement _gameBoard; private Label _movesLabel; private Label _matchesLabel; private VisualElement _loadingOverlay; private VisualElement _completedOverlay; private VisualElement _progressFill; private readonly List<CardView> _cardViews = new(); private readonly Subject<int> _cardClickSubject = new(); public IObservable<int> OnCardClicked => _cardClickSubject; private void Awake() { InitializeUI(); } private void InitializeUI() { _root = _uiDocument.rootVisualElement; // Находим элементы UI _gameBoard = _root.Q<VisualElement>("game-board"); _movesLabel = _root.Q<Label>("moves-count"); _matchesLabel = _root.Q<Label>("matches-count"); _loadingOverlay = _root.Q<VisualElement>("loading-overlay"); _completedOverlay = _root.Q<VisualElement>("completed-overlay"); _progressFill = _root.Q<VisualElement>("progress-fill"); // Создаем карты CreateCardViews(); } private void CreateCardViews() { const int gridSize = 4; const int totalCards = gridSize * gridSize; _gameBoard.Clear(); _cardViews.Clear(); for (int i = 0; i < totalCards; i++) { var cardView = Instantiate(_cardPrefab); // Инициализируем карту со спрайтом рубашки из настроек if (_gameSettings != null && _gameSettings.CardBackSprite != null) { cardView.Initialize(_gameSettings.CardBackSprite); } var cardElement = cardView.CreateVisualElement(); int index = i; // Захват переменной для замыкания cardElement.RegisterCallback<ClickEvent>(_ => OnCardClick(index)); // Добавляем класс для анимации появления cardElement.AddToClassList($"card-{i}"); cardElement.AddToClassList("card-appear"); _gameBoard.Add(cardElement); _cardViews.Add(cardView); } } private void OnCardClick(int index) { _cardClickSubject.OnNext(index); } public void ShowLoading() { _loadingOverlay.style.display = DisplayStyle.Flex; _loadingOverlay.AddToClassList("fade-in"); } public void HideLoading() { _loadingOverlay.AddToClassList("fade-out"); _loadingOverlay.schedule.Execute(() => { _loadingOverlay.style.display = DisplayStyle.None; _loadingOverlay.RemoveFromClassList("fade-in"); _loadingOverlay.RemoveFromClassList("fade-out"); }).StartingIn(300); } public void SetMovesCount(int moves) { _movesLabel.text = $"Ходов: {moves}"; // Небольшая анимация при изменении _movesLabel.AddToClassList("pulse"); _movesLabel.schedule.Execute(() => { _movesLabel.RemoveFromClassList("pulse"); }).StartingIn(300); } public void SetMatchesCount(int matches, int total) { _matchesLabel.text = $"Найдено пар: {matches}/{total}"; // Обновляем прогресс бар if (_progressFill != null) { var progress = total > 0 ? (float)matches / total : 0f; _progressFill.style.width = Length.Percent(progress * 100); } } public void SetInteractionEnabled(bool enabled) { _gameBoard.pickingMode = enabled ? PickingMode.Position : PickingMode.Ignore; } public void ShowGameCompleted(int moves) { _completedOverlay.style.display = DisplayStyle.Flex; var completedMovesLabel = _completedOverlay.Q<Label>("completed-moves"); if (completedMovesLabel != null) { completedMovesLabel.text = $"Завершено за {moves} ходов!"; } // Анимация появления _completedOverlay.style.opacity = 0; _completedOverlay.schedule.Execute(() => { _completedOverlay.AddToClassList("fade-in"); }).StartingIn(100); } public void ShowStartAnimation() { // Анимация появления карт волной for (int i = 0; i < _cardViews.Count; i++) { var delay = i * 50; // мс между картами var cardElement = _gameBoard.Q(null, $"card-{i}"); if (cardElement != null) { cardElement.schedule.Execute(() => { cardElement.AddToClassList("show"); }).StartingIn(delay); } } } public void ShowMatchAnimation(int firstCardIndex, int secondCardIndex) { // Анимация совпадения уже реализована в CardView // Здесь в будущем можно будет добавить эффекты дополнительные, может пригодится var firstCard = GetCardView(firstCardIndex); var secondCard = GetCardView(secondCardIndex); } public void PlaySound(SoundType soundType) { if (_audioSource == null || _gameSettings == null) return; AudioClip clip = soundType switch { SoundType.Flip => _gameSettings.FlipSound, SoundType.Match => _gameSettings.MatchSound, SoundType.Mismatch => _gameSettings.MismatchSound, SoundType.Complete => _gameSettings.CompletionSound, _ => null }; if (clip != null) { _audioSource.PlayOneShot(clip); } } public ICardView GetCardView(int index) { return index >= 0 && index < _cardViews.Count ? _cardViews[index] : null; } private void OnDestroy() { _cardClickSubject?.Dispose(); } } }
```

